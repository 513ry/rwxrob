<!doctype html>
<html lang="en">
<head>
    <title>I Wish …</title>
    <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"/>
  <link rel="shortcut icon" href="/assets/img/logo.png" type="image/png">
  <meta http-equiv="Pragma" content="no-cache"/>
  <meta http-equiv="Expires" content="0"/>
  <link rel="shortcut icon" href="/assets/img/logo.png" type="image/png">
  <link rel="stylesheet" href="/assets/styles.css">
  <link rel="stylesheet" href="styles.css">
</head>
<body>
<header class=nav-bar>
  <nav>
    <div class=sidebar-button>≡</div>
    <a class="homelink spy" href="/">r<span class=hideable>obs.io</span></a>
    <div class="nav-right">
      <!-- div id=search-box></div -->
      <ul class=nav-links>
        <li class=nav-item><a class=nav-link href="/coc/">CoC</a></li>
        <li class=nav-item><a class=nav-link href="/wish/">Wishes</a></li>
        <li class=nav-item><a class=nav-link href="/quotes/">Quotes</a></li>
        <li class=nav-item><a class=nav-link href="/really/">Really?</a></li>
        <li class=nav-item><a class="nav-link" href="https://rwx.gg">rwx.gg</a></li>
        <li class=nav-item><a class="nav-link" href="https://youtube.com/rwxrob/">YouTube</a></li>
        <li class=nav-item><a class="nav-link" href="https://gitlab.com/rwxrob/">GitLab</a></li>
        <li class=nav-item><a class="nav-link" href="https://linkedin.com/in/rwxrob">LinkedIn</a></li>
        <li class=nav-item><a class="nav-link" href="https://twitter.com/rwxrob">Twitter</a></li>
      </ul>
    </div>
  </nav>
</header>
<main id=top>
<div class=container>  <h1 id=title>I Wish …</h1>
  <h2 id=subtitle>Maybe Someone Will Grant Them</h2>
<p>Another reason to actually have a web site is simply a place to publicly proclaim your wishes for yourself and the world. I suppose a wish is not as weighty as a <em>goal</em> or a <em>todo</em> list. A wish is something that you just want, not that you necessarily need to do yourself. In fact, usually quite the opposite. You <em>wish</em> that someone else would do it instead of forcing you to. Inevitably, I end up granting my own wishes rather than complaining or sitting around waiting on someone else.</p>
<h2 id="lynx-hotkey-binding-to-run-a-shell-program-and-pass-url">Lynx Hotkey Binding to Run a Shell Program and Pass URL</h2>
<p>Lynx is still the faster browser in town for research, but it is a bit hard to get URLs and open graphic web browsers when needed. Having a hotkey binding to run an arbitrary shell command would be so useful.</p>
<h2 id="protobuf-vim-plugin-that-is-syntax-aware">Protobuf Vim Plugin That is Syntax Aware</h2>
<p>Currently, the Vim file type of <code>proto</code> is supported out of the box, but the syntax is not using an AST of any kind (it appears) so it can’t do things like line up in-line comments and stuff I’ve come to love about <code>vim-go</code>. This is probably the type of project I want to work on <em>after</em> finishing PEGN so that I can define the grammar of the syntax in PEGN and autogenerate a Vim plugin in Go that handles the AST.</p>
<h2 id="json-schema-to-protobuf-converter">JSON Schema to Protobuf Converter</h2>
<p>The world (since 2019) is apparently going all gaga for gRPC and its Protocol Buffer interface definition language (IDL), and, I’m thinking, for good reason. I have <em>really</em> enjoyed working with it, much more than I would have imagined having PTSD for all things RPC from previous decades. In fact, I plan on doing everything in Protobuf for new projects now because it generates the most important code in a code-agnostic.</p>
<p>That said, there is a bunch of stuff already specified in JSON-Schema that would be really nice to just convert over to <code>.proto</code> files. Such a tool does not exist so far that I can find.</p>
<h2 id="twitch-font">Twitch Font</h2>
<p>Someone needs to create a font that has close equivalents of all the most common Twitch emojis and icons. It would be a lot of work, but it would be awesome. It could be combined into a variation on one of the “nerd” fonts that already have the adjustments for powerline and stuff.</p>
<h2 id="smarter-back-utility">Smarter <code>back</code> Utility</h2>
<p>It’s just a small thing, but I want to make my <code>back in 10 minutes</code> detect the width of the script and change the figlet font according to how much room it has. I’m already doing something like that in the <a href="https://duck.com/lite?kd=-1&amp;kp=-1&amp;q=Just%20say%20No%20to%20%60nano%60%20project">Just say No to <code>nano</code> project</a> but wonder if it could just be done with a shell script just as easily.</p>
<h2 id="go-template-utility-gotmpl">Go Template Utility: <code>gotmpl</code></h2>
<p><a href="https://gitlab.com/rwxrob/gotmpl"><em>Here look I even started the repo for you.</em></a></p>
<p>It occurred to me that Go is actually the perfect language to write a little <code>gotmpl</code> utility that reads from a collection of cached templates (both <code>text</code> and <code>html</code>). Sometimes all I want is the lower of Go’s templating system for random things and usually just want to combine them with some YAML or JSON or just a list of stuff on the command line.</p>
<p>I could use it to manage snippets from within a <code>vi</code> session. Some of my my favorite methods to add to a simple data struct:</p>
<ul>
<li><code>String() string</code> - the <code>Stringer</code> interface as JSON</li>
<li><code>JSON() []byte</code> - compressed JSON buffer</li>
<li><code>Print()</code> - <code>fmt.Println()</code> of the string JSON</li>
<li><code>Parse(jsn64 []byte) error</code> - JSON (optionally base64 encoded)</li>
<li><code>Load(path string) error</code> - <code>ioutil.ReadFile()</code> then <code>Parse()</code></li>
<li><code>Base64() []byte</code> - <code>JSON()</code> in base64 encoding</li>
</ul>
<p>I should probably also make something that creates the <code>Example*</code> test cases as well. Actually, I should just do one <code>ExampleData()</code> (or whatever) and then just include a bunch of examples of using all the related methods.</p>
<h2 id="mainmaker-generator-replacement-to-go-cobra-commander">MainMaker, Generator Replacement to Go Cobra Commander</h2>
<p>I fucking hate the <a href="https://github.com/spf13/cobra">Cobra Golang commander module</a>. I always have. It is far too heavy and invokes a external dependency for no good reason. I <em>know</em> it is used in Hugo and Docker. I don’t need the reminder. It’s one reason I hate it. It sucks ass. The people who created it and maintain it — especially Steve — are absolutely amazing people. This isn’t about them or how great their programming skills are. It’s about the shitty design of a shitty module that squandering an excellent opportunity to be what the modern, conversational, sub-commander CLI world <em>really</em> needs. Instead, it perpetuates the Boomer-era bullshit we’ve come to tolerate and not question because we think we just have to accept it. We don’t.</p>
<p>Perhaps the most annoyingly brain-dead thing Cobra does is generate a tab completion shell script that actually encourages people to put <code>eval</code> in their configuration files. It is as if no one on the Cobra team ever even RTFMed the Bash <code>man</code> page about <em>Programmable Completion</em> that clearly says you could have used the option to run a program instead (<code>-C</code>). So instead of that big fucking, unnecessary shell script you could have written all the completion code <em>in Go</em> in your program instead. Duh. What’s worse is encouraging people to use <em>the far more secure practice</em> of adding <code>complete -C foo foo</code> to their shell configuration files instead. No need to have root access to put files in <code>/etc/bash...&lt;whatever the fuck&gt;</code>.</p>
<p>Stupid, right?</p>
<p>Rather than just complain I actually tried to follow my “don’t get mad, get busy” mantra and fixed these glaring problems in my <a href="https://gitlab.com/rwxrob/cmdtab">cmdtab</a> package. But I’m even realizing <em>that</em> we can still do better. The unnecessary methods always bothered me. We know enough about the program when we are building the thing so why spent all that wasted run-time just to figure out the arguments and get them to the right place? My commander — as <em>beautiful</em> as it is when it comes to combining completion with amazing documentation that travels <em>with</em> your command instead of in addition to it requiring it to be installed — missed one <em>major</em> advantage that <em>no one</em> has created: zero dependency with code generation.</p>
<p>Yep. The last great frontier for the world’s best commander is code generation. By moving this work into a tool instead of a module we drop the dependency entirely and have sustainable code that we can even tweak to our hearts content. <em>That</em> is the Holy Grail. <em>That</em> is something Rob Pike would likely actually approve of. (You’ll never get his honest opinion of Cobra, I promise.) The start up speed impact would be even more negligible because the generated code has intimate knowledge and far less indirection through flow control and unnecessary function calls. There’s simply nothing faster and more elegant. It <em>has</em> to be made. Someone make it before I have too.</p>
<h2 id="terminal-typing-training">Terminal Typing Training</h2>
<p>All the web tools are lame. Even those designed for coding suck pretty badly. There needs to be an exciting terminal typing training tool that allows all the keys a technologist needs to be learned. By creating snippets in a given language it can double as a method of familiarizing oneself with a particular language syntax while at it.</p>
<p>I’d like to write it in Go using the <code>cview</code> GUI library.</p>
<h2 id="namecheap-command-line-interface">Namecheap Command Line Interface</h2>
<p>I use Namecheap a lot when looking up domains. It would be nice to have a better search capability from the command line than the horrible graphic user interface.</p>
<h2 id="restream.io-command-line-tool-with-chat">Restream.io Command Line Tool with Chat</h2>
<p>I <em>really</em> need finish the <a href="https://restream.io" class="uri">https://restream.io</a> API command integration. I’m hopeful that the Websockets API it provides does what is necessary to replace my WeeChat TMUX pane on my live stream. Please someone do it for me so I don’t have to make it. Who am I kidding, I’ll have to make it myself or I’ll never be satisfied. At least I could fork it, I suppose. It just doesn’t exist right now because no one cares about the terminal anymore, too many low-brow graphics interface users overwhelm the minority interests of we terminal people.</p>
<h2 id="replacement-for-find-with-a-good-query-language">Replacement for Find with a Good Query Language</h2>
<p>The <code>find</code> command is an essential tool for system administration — particularly for disk usage and security audits — but the syntax of the arguments has always been ridiculously difficult to remember requiring multiple references to the man page.</p>
<p>Wouldn’t it be cool if we came up with <code>find</code> replacement that has a drop-dead simple query language (maybe even just SQL) that it read either as a single string or passed into standard output, or just placed in a file with a she-bang line pointing to it. It would be an <em>actual</em> language for finding things on your system (no not like <code>awk</code> or <code>sed</code>).</p>
<p>One approach would be simply to create SQLite flat-database files and a light-weight interface to them so that existing SQL tools could be used. This is something that could be done rather quickly. By having different SQLite files created queries could be made across databases to determine changes in the file system.</p>
<h2 id="nark-an-open-source-tripwire-replacement-idea">Nark, An Open-Source “Tripwire” Replacement Idea</h2>
<p>The original <a href="https://github.com/Tripwire/tripwire-open-source"><code>tripwire</code></a> seems to be alive and well. However, it looks like it could use an update and perhaps a rewrite in a modern language (like Go or Rust). I’d also like to focus on the reporting aspect above all and add both inbound and outbound ports to the monitor to “nark” on (get it) stuff that is not supposed to be on my system.</p>
<p>Another consideration would be the license change from GPLv2 to Apache.</p>
<p>What a great project this is for learning a specific language as well? It’s practical, uses tech and techniques that are relevant, and it’s relatively simple to implement.</p>
<h2 id="watch-with-me-application-service">Watch With Me Application / Service</h2>
<p>In order to comply with copyright law live streamers cannot do what they would normally do, listen to copyrighted music and watch their favorite videos and movies. This sucks because in order to live stream currently you have to give all that up, but that is part of the fun of being a coder, being able to jam out to Cake while banging on the keyboard. Something needs to be created that keeps everyone watching the stream informed about the URL and the location within the content enabling stream viewers to be at exactly your same location so that people can chat about it and comment on it like Mystery Science 3000. It might be something as simple as a browser plugin and a service that can be periodically polled by the plugin.</p>
<p>And another thing, I don’t necessarily want to force those watching my stream to listen to my music, or to watch the movies I’m watching. They might now want to be distracted or perhaps they have their own music. I’ve heard people say they actually <em>don’t like</em> streams that have music for that reason.</p>
<p>To date, most streamers will jam out with headphones without their viewers knowing what they are listening to. That’s fine, but it sort of misses the point — especially when wanting to view documentaries together and such.</p>
<h2 id="coder-coffee-shop-desktop-app">Coder Coffee Shop Desktop App</h2>
<p>I’d love to just be able to pull up an app on a secondary screen and see everyone’s screens while they are coding. The app could rotate through random people and give them a 4x size for a bit just to highlight what different people are working on. Those screens that don’t change could auto-minimize themselves so only people doing stuff would be on the screen. Then we could add like a Discord chat room with it all. The one solid requirement would be that it not crash constantly.</p>
<p>Even something that is just terminal based would be amazing, perhaps something like what TMUX or Screen shared session do right now.</p>
<h2 id="reformed-educational-systems-focused-on-learning">Reformed Educational Systems Focused on Learning</h2>
<p>Most public education systems (and most private ones as well) are not <a href="https://youtu.be/GFD37HvGx6k?t=181">focused on learning</a>. They are focused on meeting quotas, perception management, making money, pushing people through, and glorified child-care. The most motivated teachers in such a system simply cannot accomplish true learning in their students. When learning happens it comes at the cost of dependency on the teacher and system instead of producing true autodidactic individuals ready to face the world.</p>
<p>Teachers who have gone through the formal education to become one either love or hate that when I say this. I’m convinced the science surrounding education is seriously flawed and focused on the wrong outcomes. Ken Robinson agrees. This is why I want nothing to do with traditional academia and teacher certification. It turns well-intentioned teachers into drones with their aspirations burned out by an objectively failing system with upside-down priorities.</p>
<p>The path to reform means significantly changing the culture of education. It means turning teachers into mentors and learning facilitators, not subject-matter experts who have <em>actual</em> experience. It means obliterating ego and promoting empathy in the learning environment. It means having SMEs and facilitators working together. The SMEs produce the content, challenges, and activities. The facilitators organize learning lab environments where <em>the learner is in charge of their own learning</em>. Responsibility for learning is placed on the learner from the very beginning rather than creating an antagonistic teacher versus student approach we have today. We need the courage to work toward motivational skills and let those unwilling to learn simply not learn, to hold them back for as long as it takes until they decide on their own terms to begin and own their learning instead of trying to <em>force</em> them to learn.</p>
<p>These techniques have been proven successful over and over again in environments where the traditional systems gets completely out of the way, from the groups of “lost learners” who are essentially thrown into detention during school all day, to the “gifted and talented” deemed to smart for the current system. Both of <em>those</em> systems flourish because the teacher is not a teacher, but a motivator, a facilitator, and yes, even a responsible friend.</p>
<p>All of the plights of 2020 can be traced back to a lack of good learning. Those who learn and love to learn discover empathy and facilitators working in this way <em>must</em> be above all experts in emotional intelligence and empathy, councilors more than teachers. Most people who remember their “best” teacher will recall all of these qualities in that person who operated this way within a seriously broken system.</p>
<h2 id="better-peg-grammar-notation-and-tooling">Better PEG Grammar Notation and Tooling</h2>
<p><em>Update: I’m actually <a href="https://pegn.dev">making this</a> if you want to help.</em></p>
<p>PEG (<a href="https://duck.com/lite?kae=t&amp;q=Parser%20Expression%20Grammar">Parser Expression Grammar</a>) is by far the most important advance in language grammar development in the last 20 years (even though many CS departments still don’t even talk about it in their curriculum). The ecosystem around PEG is fractured and full of over-engineered code generators that are implementation language specific. What we need is a standardized notation based on Bryan Ford’s original (but incomplete) “example” in his paper that started it all. Then we need to show that tooling can exist — including code generators — that simply use the grammar and don’t intermix PEG with additional syntax to render in a specific language. That way the same grammar files can be used to generate parsers of different kinds in different languages. The same grammar file could be used to generate a highly optimized parser within a single file or another that uses very flexible AST approach and parse function library.</p>
<p>PEG is particularly useful in computer science education not only to create grammars, but to document existing ones and get the mind to understand what syntax is as well as any specific syntax. Capturing an existing language in PEG is a great educational exercise.</p>
<h2 id="fast-one-pass-parsable-markdown-ezmark">Fast, One-Pass Parsable Markdown (Ezmark)</h2>
<p>Markdown is amazing, but not even the CommonMark initiative has recognized the value in creating a version of Markdown that can be parsed in one pass instead of two. This is because of reference links and other stuff in blocks at the bottom of a Markdown document that must be parsed before anything above can be rendered that depends on them.</p>
<p>All the advances in Markdown — mostly in Pandoc — have been toward become more flexible with adding extensions and providing more and more additions to the syntax. This is entirely against the original goal of a standard, simple language that is better than HTML than anyone can learn in 20 minutes. We need a Markdown that enough people could use without a lot of training not just because it is simple, but because HTML needs to be replaced with some version of Markdown.</p>
<h2 id="a-decentralized-knowledge-network">A Decentralized Knowledge Network</h2>
<p>This is one I have been working on for several years, something to replace or supplement the world wide web that maintains the motivations of the original web: knowledge exchange. It will leverage the infrastructure of the web without depending on it. It will provide localized content searching through semantic structuring, parsing, and local caching. It won’t even need a network. It will provide digitally-signed attribution of authorship. It will use trust to improve content discovery.</p>
<p><em>Development is moving along slowly <a href="https://gitlab.com/rwx.gg/kn">here</a>.</em></p>
<h2 id="bash-shell-rewritten-under-better-license">Bash Shell Rewritten Under Better License</h2>
<p>Seriously, Bash is so bloated and the code base so old and crusty that the whole thing needs a serious rewrite under a license that will allow it to ship on embedded hardware and such instead of Bash because of its completely stupid <a href="https://rwx.gg/views/gnuisdead">GPLv3 license</a>. (No <a href="https://rwx.gg/advice/dont/zsh">Zsh is <em>not</em></a> the answer.)</p>
<h2 id="kick-ass-educational-chemistry-3d-shooter">Kick-Ass Educational Chemistry 3D Shooter</h2>
<p>I’ve long wanted someone to take me up on the idea of creating a really rated M educational chemistry shooter that does <em>smell</em> like a “for education” game. It could be a full triple-A game that requires you to prepare different ammo and weapons to fight an wildly different set of monsters and mobs using the right stuff. There could be a chem lab where you see the periodic table in 3D, play around with simulated combinations of all the chemicals to learn about their properties and more.</p>
<p>Hell just a realistic chem lab that taught about what happens when you combine different chemicals would be amazing.</p>
<h2 id="full-yaml-1.2-and-jq-parser-command">Full YAML 1.2 and JQ Parser Command</h2>
<p>The <code>jq</code> command is absolutely phenomenal. It just only exists for JSON. There needs to be a <code>yq</code> as well that is <em>good</em> — not that Python PyYAML shit. It also needs to be written in Go, C, or Rust and maybe have a lot of the unnecessary query stuff removed. It could be installed as <em>both</em> <code>yq</code> and <code>jq</code> and detect how it is called in order to process data differently. Fuck the old <code>jq</code> which never plans to support more than the “JSON internal structures”.</p>
<p>Such a tool would be so monumentally useful it might even put a serious dent in the use of databases in general. Something that supported that level of power, including the full remote files idea, would completely dominate the flat-file data management space.</p>
<h2 id="yaml-lite">YAML “Lite”</h2>
<p>Let’s face it. YAML kinda sucks. It allows for execution of code and does far more than it ever should. There needs to be a subset of YAML that is strongly specified, a YAML <em>lite</em> so to speak.</p>
<p>The tough part would be deciding what to throw out and what to keep. For example, some people despise linking, but I love it. It saves on so much redundancy when using YAML as a replacement for a database — one of its stronger use cases.</p>
<p><del>If</del> When I finish <a href="https://pegn.dev">PEGN</a> something like this will be a lot easier to consider.</p>
</div>
</main>
<footer>
  <p><a href="/copyright/" id=copyright>© 2020 Rob Muhlestein</a></p>
</footer>
<script src="/assets/main.js"></script>
</body>
</html>